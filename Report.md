In the current assignment, we made the seven system calls mutex_create, mutex_lock, mutex_unlock, cond_init, cond_wait, cond_signal, testandset which can be all found under system directory. Pointers of type mutex_t and cond_t is created in xsh_babybird.c and it's references are passed into the mentioned system call. The mutex_create sets the variable value equal to zero. mutex_lock internally uses test and set mechanism to allow only one process to lock the variable and if any process tries to set lock on the already locked variable that process goes into busy wait until the lock is free. mutex_unlock makes the lock value zero. testandset function is like the testandset instruction in some processors. It makes the lock value 1 and returns previous lock value. cond_init initializes lock value to zero. cond_wait unlocks the mutex and busy waits until the conditional variable is equal to 1. cond_signal makes the condition variable equal to 1. Using mutex and conditional variables like semaphores we are about to achieve synchronization necessary in babybird problem.





1. What is starvation? Is this protocol starvation-free?
Answer: In operating systems when a process is denied service for indefinitely long time then it is said to be in a state of starvation since it starves for processor time. It may happen because of bad design or poor coding. Many times, it is a resource management problem where many processes compete for a shared resource and some processes monopolies the resources thus making other processes to fall into starvation. In operating systems where schedulers select processes with highest priority the low priority process may fall into starvation if there is always a higher priority process present. Some systems are design in such a way that the priority of the processes is increased with time so that processes with low priorities don't fall into starvation. 

The protocol given in the assignment is free of starvation. A process that gets inside the loops will eventually get out in some time. It may take long time if there are many process accessing the function concurrently but it won't take indefinite time.

2. What is deadlock? Is this protocol deadlock-free?
Answer: Deadlock is a state when no processes can get the processor since they are all waiting on some resources in some cyclic fashion.
For example: Let's say process1 wants resource 1 to execute further but is held by process 2. When process 2 gives up the resource 1 the process 1 can continue. Suppose process 2 is waiting for resource 2 which is held up by process 1 and process 2 can't move further until it can get resource 2. Now in this state both processes are dependent on resources held by other. The processor may be free but both processes won't be able to get it since they are waiting for a resource held by other. This is a deadlock state.

In the given protocol deadlock can occur. Let's say process 1 calls the lock function and the lock is not yet set. It sets the local variable me equal to thread id of process 1 (let's call it 1). Now me = 1. Process 1 goes inside the double do loop and sets global variable turn = 1. Since busy is false it will come out of inner do loop. It then sets busy = true. Let's say now current process is reschedule. Process 2 may now enter lock function, set local variable me = 2, go inside double do loop and make global variable turn = 2 (thread id of this thread or process). But since busy is true it won't be able to get out of inner do loop. It's going to run in infinite inner loop. After some time, process 1 may get processor back and starts execution after line busy = true. But now process 1 won't be able to get out of outer do loop as turn is global variable and is set to 2 by process 2 while me is local variable its value is 1 for process 1. The condition remains true and process 1 runs in infinite outer loop. This is deadlock state since both the process won't be able to get out.